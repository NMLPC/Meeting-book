## RSA针对指数进行攻击

- ### 低加密指数攻击

**适用情况**：e 过小，一般来说 n，c都较大。

**原理：**根据公钥加密机制，密文c=m^e mod n。如果选取的 e 过小，加密指数过低，就会引发安全问题

1. 如果 e 过小导致 m ^e < n，可以推出 c = m^e，此时直接对密文开e次方即可得出明文
2. 对于 m^e > n，根据j加密公式变形得：m^e= k*n+c(k为正整数)，由此，我们可以通过爆破k来获得m^e，之后再开根号即可获得明文

```
##flag.enc
85 C0 DE 5F 89 E8 87 20 AF D4 85 F9 1D ED 38 E9
EA ED A3 A6 1D DE E7 08 7B BD 29 92 0E E4 0B 6D
53 56 5E DD 1E 41 80 95 58 6B D4 F3 30 15 72 9D
43 3A F4 13 C6 60 E4 C0 B1 64 ED 02 5F 91 21 6D
90 45 78 F7 F2 0C 5F B1 E0 9E 71 99 21 98 D8 E8
D7 FB D9 17 59 7A EE 45 EB F4 CA 80 12 4C E9 B4
7E D1 63 F0 B9 D5 71 6A 9D 6E 1F 5B 8A E0 9B 16
CA E3 0B BD 64 A1 5E 17 CC 39 A9 0F B6 25 36 AD
94 3C DD A9 A4 AA C5 97 8E 3C 93 50 25 35 D5 35
36 38 BC 70 8C 9B 59 CC 9D C7 BC B1 D8 73 33 6C
E0 81 59 15 22 B1 D4 89 04 46 37 83 DD 68 37 B1
C4 1B 80 11 88 96 48 E0 AC DF BD 3E E2 59 F7 17
99 08 28 D1 6D B3 4E B9 82 44 62 16 DB 53 4D C0
6B 9E 7A AF 90 BC CB 54 A1 CC 77 C2 81 3B DF E9
A1 B5 C2 E9 58 C3 EA 8C A1 03 BA 1A 89 03 6B 70
14 BB C9 62 EB 7A 8C 91 0E 09 5B B8 37 91 BD 9F
EE E0 D8 F6 AF 0C 2E 03 0C CC C6 D8 72 97 43 41
9B DE E0 A1 E4 5A B5 E7 32 4A 34 47 61 C8 CC 8D
B3 09 61 A9 71 D5 66 E4 9C 45 62 92 4C 3E E0 01
ED EC E3 44 5C D2 8D BA 26 4B A8 A9 0C 5E 53 35
42 09 6C 26 AA 7D 87 49 97 A3 08 02 5A 5E 95 BF
C6 94 9E BD 16 CE A8 89 D2 42 AB 2E 2F F2 44 60
90 D0 76 66 D7 57 49 46 E3 91 D3 F1 53 D5 03 46
BC 75 DA 94 63 41 82 DF 80 F7 BA 97 B7 7A F8 92
2F 13 E4 3B 2D F7 88 90 2A 20 9B 9E 56 9D D3 C6
FA A4 DD 7B 43 89 9F 59 79 88 45 DF 64 2E DE EF
34 A1 86 94 9C BE 83 C0 99 F0 85 F8 7A 29 95 91
E7 15 CC B4 FE 74 61 2B 00 AE BE 25 C1 14 81 9C
F8 87 C2 56 12 19 15 41 6A CB CB 05 89 37 E3 D3
9E B7 EF 71 43 E1 45 13 11 19 DA 9C 3D 98 18 59
9A 0E 51 09 72 7F B5 81 BB C2 0E B3 E6 A2 50 11
B8 E9 03 45 37 C0 E5 80 A0 EE 8F 15 53 80 5B E8
```

```
##pubkey.pem
-----BEGIN PUBLIC KEY-----
MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY
/Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs
pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff
0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON
Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg
Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF
ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG
gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl
UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE
JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC
LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP
EkP0OHRGzM6yIiqWXMMLOSkCAQM=
-----END PUBLIC KEY-----
```



```
E:\enviroment\python3.7\python.exe E:/code/python3/luogu/temp.py
n: 721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241
e: 3
c: 545666236924510340010249577709750283325731706774285241719627277546281629429734726717293022303311450772262647904537263500252284243393598944613964442974546950954108203106726282255676706429218187217515454665602130999856741523362906632677988245886500953095201122016935004088287862399317170828388632964668574391252399791901016522260191839164586088073933168096433230663402492577707149742261018318811473591856287943664733276898405984282679026758294364432874973387827086342720762945025346962005339728347282927842299962927871005260338747371451546554777112213044710533502191671159066680035742327279159127279685106716107705888068319962657817786581813767331740609788885735155741039564703781141646102609725965697004923161084032164730408824475517786576979990372940555488021025837456038491436690372760376483602299268887032528766383572923258228355911069631275397149328319966792315903921085816103476508992023873616148326626245855060470294978538631677232260545724075728912626994884533001056079733734460116442499311813113038763837974777469202302071221647473459505245546281400799833123812072606012604323510933244028733287443734697557314202167934768160824072400916728008549350662843995750077421616789178835625661267955774815287104291379928002318796086248

```



对密文、公钥处理一下获取信息发现 n,c长的过分，e=3

```
from Crypto.PublicKey import RSA
import base64
import gmpy2
from Crypto.Util.number import *
r=open('../CTFquestion/RSA/pubkey.pem').read()
pub=RSA.importKey(r)
#读取pem文件，获取n，e
n=pub.n
e=pub.e
print("n:",pub.n)
print("e:",pub.e)
#读取enc文件，获取c
flag_encode= open('./flag.enc','rb').read()
print("c:",int(flag_encode.hex(),16))
c=int(flag_encode.hex(),16)
k=1
#枚举开方结果，iroot方法为求某个数的某次方，返回(开方结果(int),能否开整数次方(bool))
while 1:
    m,f=gmpy2.iroot(n*k+c,e)
    k+=1
    if f:
        print(m)
        print(long_to_bytes(str(m)))
```



- ### 低加密指数广播攻击

**适用情况**：e很小，给出多组 n 和 c相对应的情况

**原理**：根据已有信息可列方程组

| c1 = m^e mod n1 |
| --------------- |
| c2 = m^e mod n2 |
| c3 = m^e mod n3 |

通过中国剩余定理进行计算。

**一般攻击方法：**

设共有 i 组方程

1. 计算出M：所有n的乘积
2. 对于每一个ni计算出mi：mi=M/ni
3. 计算每一个mi对ni的模逆ti：ti*mi % ni=1  (a,ti,k=gmpy2.gcdext(mi,ni))
4. 计算每一个mi*ti*ci的值，累加起来对M取模得到m^e
5. 开e次方得到明文m

例题：Hack You CTF 2014: Cryptonet

```
#https://www.voidsecurity.in/2014/01/hack-you-ctf-2014-crypto-400-cryptonet.html
#!/usr/bin/env python

from scapy.all import *
from sage.all import *
import zlib
import struct

PA = 24L
packets = rdpcap('packets.pcap')
client = '192.168.1.5'
size = 2 # size of e and n is packed into 2 bytes
list_n = []
list_m = []

for packet in packets:
    if packet[TCP].flags == PA:
       if packet.dst == client:
           src = packet[IP].src
           raw_data = packet[TCP].load

           size_e = struct.unpack('!H', raw_data[:size])[0] 
           e = int(zlib.decompress(raw_data[size: size + size_e]))

           size_n = struct.unpack('!H', raw_data[size + size_e: 2 * size + size_e])[0]
           n = int(zlib.decompress(raw_data[2 * size + size_e: ]))
           list_n.append(n)

        if packet[IP].src == client:
            raw_data = packet[TCP].load
            size_m = struct.unpack('!H', raw_data[:size])[0]
            m = int(zlib.decompress(raw_data[size: size + size_m]))
            list_m.append(m)

e_17 = crt(list_m, list_n)
factors = prime_factors(e_17)
enc_message = 1
for num in factors:
    enc_message *= num

print hex(enc_message).decode('hex')
# 'Secret message! CTF{336b2196a2932c399c0340bc41cd362d}\n'
```



- ###  低解密指数攻击（Wiener attack）

**适用情况：**e很大，一般n，c也很大，难以分解

**原理**：与低加密指数攻击类似，由于d 是 e对 φ(n) 的模反元素，因此 e 如果过大势必会引起 d 过小，即解密所用指数过小，同样会引发安全问题。类似的体型涉及连分数展开和渐进方程计算。

```
##bugku例题
N : 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597
e : 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619

enc : 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192
```



方法一：

使用RsaCtfTool对RSA进行攻击：命令如下

```
python RsaCtfTool.py --createpub -n 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597 -e 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619 >test.pem
##(n,e)封装为公钥用于加密

python RsaCtfTool.py --publickey test.pem --private >test.key
python RsaCtfTool.py --key test.key --dumpkey
```



方法二：

```
from Crypto.Util.number import long_to_bytes
e=354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619
n=460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597
c=38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192
 
#连分数展开算法
def lf(x,y):
    arr=[]
    while y:
        arr+=[x//y]
        x,y=y,x%y
    return arr
 
def jj(k):
    x=0
    y=1
    for i in k[::-1]:
        x,y=y,x+i*y
    return (y,x)
data=lf(e,n)
for x in range(1,len(data)+1):
    data1=data[:x]
    d = jj(data1)[1]
    print(long_to_bytes(str(pow(c,d,n))))
```

```
b"Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: PCTF{Sm4ll_3xpon3nt_i5_W3ak}\n"
```



- ### 共模攻击

**适用情况**：多组密文使用同一个模数n加密的情况，不同e之间两两互质

**原理**：通过欧几里得算法可以知道给定整数e1 与 e2, 必存在有整数 s1与 s2使得$e_1s_1 + e_2s_2 = gcd(a,b)$。根据扩展欧几里得算法，给定e1，e2，求解出$s_1$，$s_2$，然后根据推导得出的公式计算m

**证明：**

$贝祖公式：e_1\times x+e_2\times y=1$

$由于:c_1=m^{e_1}\%n	$	

$---  c_2=m^{e_2}\%n$	

$所以：(c_1^{s_1}\times c_2^{s_2})\%n=((m^{e_1}\%n)^{s_1}\times (m^{e_2}\%n)^{s_2})\%n$

$所以：(c_1^{s_1}\times c_2^{s_2})\%n =(m^{{e_1\times s_1}+{e_2\times s_2}})\%n$

$因为:e_1\times s_1+e_2\times s_2=1$

$所以：c_1^{s_1}\times c_2^{s_2}=m$

由此可以得到明文m。

```
##欧几里得算法-递归实现
def ext_euclid(a, b):
    if b == 0:
        return 1, 0, a
    else:
        x, y, q = ext_euclid(b, a % b)
        # q = gcd(a, b) = gcd(b, a%b)
        x, y = y, (x - (a // b) * y)
        return x, y, q
```

```
##flag.enc1
71 B3 8B 33 CA D0 F3 BF 34 D7 26 AC AC 37 83 6E
C1 5B 15 9F B7 01 E7 A6 2B 7D 2A CE 5E 05 F3 F8
A3 C3 24 58 D6 9E E7 AB 04 C2 2B 4C AE 08 66 B9
64 C2 16 49 EB B6 B9 57 D0 AE EA FA CF 9D 6A FC
DF 8D F1 C8 64 8B F3 9E B7 52 9E 1C C0 5B E9 0E
A4 D9 BF 14 CA E8 1F 63 84 25 98 90 75 75 E4 44
EC 3F 70 EF AC C0 9F 9D 70 14 81 D9 DB 0D DE 72
2F 49 C2 95 9B 08 7F 37 01 2F ED 3F 99 39 1D B7
33 69 5E F4 E5 10 2E 72 4A 40 EA C0 DC 14 70 D9
23 B5 86 41 D1 F7 DD B1 18 6C 98 AA 15 7F 11 6B
BB 52 FD 3F 34 39 35 F2 E4 7E A5 A5 86 09 06 8C
BE 33 B1 B9 5A EC C7 45 A4 82 0C CE 67 8A 2B 36
AA 03 9A 93 25 CF 96 94 5B C6 F1 69 59 1C FF 6F
3A 54 BE C8 DF 1B 34 17 29 DA 94 89 BC 76 95 F3
DA F4 1A 48 88 C7 AB 9F AE 7A 75 3A 78 F7 89 15
22 CC 95 2B 88 0F ED 4D 1C 40 04 24 F3 12 F4 80
1C FE F4 A7 EB AF 3A BF 5E 2F B2 4B E6 9B ED 69
03 69 4C 3B A5 AA 4B 81 E0 64 00 A2 FB B2 D2 F9
53 83 25 17 6E D1 0F 17 B7 B2 F1 A3 C5 D8 53 57
12 67 81 CB 97 94 84 A9 3A CF 2C 5D 20 DA 22 05
5A 4F FC 8E 17 43 63 04 6D 91 E0 1F CB 5C 7B 4C
38 44 C1 49 4A 2D 96 4E 66 9D 59 EB 2A 6E CD 18
F7 59 14 DE 74 8C A1 82 23 3C 8D 6A 4D A7 C7 E7
61 1A 2F B5 A9 C0 BA 26 B2 8E 6F 5E AE AD DA 4B
B2 CC 5F 41 A7 16 C6 D1 04 36 62 B5 F4 53 05 EB
EC A8 53 A3 03 53 47 D6 59 61 B3 D0 83 75 2D 69
2C B6 F1 48 BF 69 EE AA 4A F5 86 A7 FD 90 90 73
37 7C 51 24 E5 1A 6D 8E 38 84 05 94 EF 5A E3 F6
49 7A 2A 9E C0 6A CC 63 E6 65 C9 6E 76 80 1E 9A
27 1C 59 7E 26 37 01 8A A3 41 EF 9F 32 1B 9B F8
1E C8 43 44 FB CB 04 0B B7 05 D4 B7 13 FE 60 07
E3 0A 88 16 EE AE 56 11 10 B9 5C DA 1C A6 41 81


##flag.enc2
30 06 8A 18 3D 16 35 C7 B0 6C 07 DA 18 A0 A3 9A
33 29 8C 73 4E 3E DB 6C 55 A8 3D D2 3B 62 0C D0
52 AD 5D C0 19 0C 5C 99 8D 76 09 3D 36 32 10 19
8D 55 90 2F 28 5F 74 D4 B0 EE CC 6E 29 6A 86 EF
3D 4F 25 25 A5 12 8E 9C 1A 0D 07 A6 10 C6 52 75
D5 D0 5D CE BE 3A A1 98 91 1F 1E D3 33 61 18 5B
2C D7 B6 AB AA 2A CA 51 29 94 F3 4C F0 29 AF 91
BE A7 F6 4D 48 69 D4 2C 90 AD 98 3C 24 D6 78 70
E5 A4 5E D3 7F 45 FC 4D C2 46 45 75 2F 38 4E 92
86 54 12 7D 1F 1F 83 88 31 A4 2D C4 DF 76 AF 88
A8 8B AC B6 94 5B 22 C4 67 64 C0 31 D3 32 FE A2
3D 8F D9 AD BB BA 23 94 75 9E F4 FD BE FC 60 A2
77 C4 65 FC 11 90 BF D2 95 F7 56 FF 8C 09 6B 6F
35 18 B6 B7 3A 7B DC 02 A1 2B 8A 43 BB A5 89 48
D3 ED 62 81 5B F1 C5 E5 1D 51 B8 22 3F 15 32 EC
D4 26 DF C7 69 BC DB 20 73 86 FE 2D 85 15 F1 AD
B3 55 FE 0F A9 6D 06 85 69 73 C8 0B D3 C0 8C F3
77 93 91 E7 B0 7A 31 61 6D E5 30 09 E9 BD BD 67
69 3A E1 59 9F 6B 4B AE DF 37 0C 45 1F 2D 5C 7F
67 82 A9 2B F9 10 52 4A B5 44 51 20 E7 CD 71 73
31 CE 33 25 36 30 C3 DC A3 BB A9 30 8B A1 54 6B
47 7C FA B1 71 03 BA 43 50 E5 A4 0F 28 12 FD 3F
30 3B 52 18 C9 CA 25 CE 64 AA 51 E7 F2 D0 26 AC
82 78 4F 86 0E 72 37 34 93 56 C7 DC 23 A4 19 FE
0E 21 5E CF D2 4D D5 AE 5E 59 D6 B6 8C A1 71 00
78 91 F9 63 2F 3B 0D 07 58 38 FA 29 54 0A 4F 3A
E8 42 EE D7 CA 92 0F 33 63 30 95 A9 AB 48 96 10
A0 13 1A 10 13 AD 4D 2C CF 00 A8 A6 FB 19 43 A3
92 A4 89 AB 75 07 CF 65 AF FA 31 B4 DB 14 85 1A
E0 11 5F 91 19 F4 FB FC B6 58 7D E8 EE FB B8 86
DD C1 06 C9 5B F6 97 E1 D9 DF 3D AF 89 9F D6 7A
94 29 22 EE 79 AE 5C F4 1F EE 42 F5 0E 53 7E 67
```



```
##veryhardRSA.py
#!/usr/bin/env python

import random

N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L

def pad_even(x):
	return ('', '0')[len(x)%2] + x
e1 = 17
e2 = 65537

fi = open('flag.txt','rb')
fo1 = open('flag.enc1','wb')
fo2 = open('flag.enc2','wb')
data = fi.read()
fi.close()
while (len(data)<512-11):
	data  =  chr(random.randint(0,255))+data
data_num = int(data.encode('hex'),16)
encrypt1 = pow(data_num,e1,N)
encrypt2 = pow(data_num,e2,N)

fo1.write(pad_even(format(encrypt1,'x')).decode('hex'))
fo2.write(pad_even(format(encrypt2,'x')).decode('hex'))

fo1.close()
fo2.close()
```



```
##解密脚本
from Crypto.PublicKey import RSA
import gmpy2
from Crypto.Util.number import long_to_bytes
#扩展欧几里得算法
def ext_euclid(a, b):
    if b == 0:
        return 1, 0, a
    else:
        x, y, q = ext_euclid(b, a % b)
        # q = gcd(a, b) = gcd(b, a%b)
        x, y = y, (x - (a // b) * y)
        return x, y, q
n=1#n过长，贴代码超长了，使用的时候用你的N替换
e1=17
e2=65537
flag_encode= open('./flag.enc1','rb').read()
c1=int(flag_encode.hex(),16)
flag_encode= open('./flag.enc2','rb').read()
c2=int(flag_encode.hex(),16)
print("c1:",c1)
print("c2:",c2)
s1=ext_euclid(e1,e2)[0]
s2=ext_euclid(e1,e2)[1]
if s1<0:
    s1=-s1
    c1=gmpy2.invert(c1,n)
if s2<0:
    s2=-s2
    c2=gmpy2.invert(c2,n)
m=long_to_bytes(str(pow(c1,s1,n)*pow(c2,s2,n)%n))
print(m)
```

